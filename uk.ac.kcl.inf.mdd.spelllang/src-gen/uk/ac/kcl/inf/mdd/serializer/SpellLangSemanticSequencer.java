/*
 * generated by Xtext 2.33.0
 */
package uk.ac.kcl.inf.mdd.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.inf.mdd.services.SpellLangGrammarAccess;
import uk.ac.kcl.inf.mdd.spellLang.ComplexSpell;
import uk.ac.kcl.inf.mdd.spellLang.Model;
import uk.ac.kcl.inf.mdd.spellLang.Move;
import uk.ac.kcl.inf.mdd.spellLang.Say;
import uk.ac.kcl.inf.mdd.spellLang.SpellDefinition;
import uk.ac.kcl.inf.mdd.spellLang.SpellInvocation;
import uk.ac.kcl.inf.mdd.spellLang.SpellLangPackage;

@SuppressWarnings("all")
public class SpellLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SpellLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpellLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpellLangPackage.COMPLEX_SPELL:
				sequence_SpellExpression(context, (ComplexSpell) semanticObject); 
				return; 
			case SpellLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SpellLangPackage.MOVE:
				sequence_Move(context, (Move) semanticObject); 
				return; 
			case SpellLangPackage.SAY:
				sequence_Say(context, (Say) semanticObject); 
				return; 
			case SpellLangPackage.SPELL_DEFINITION:
				sequence_SpellDefinition(context, (SpellDefinition) semanticObject); 
				return; 
			case SpellLangPackage.SPELL_INVOCATION:
				sequence_SpellInvocation(context, (SpellInvocation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (spells+=SpellDefinition+ session+=SpellInvocation+)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpellExpression returns Move
	 *     SpellExpression.ComplexSpell_1_0 returns Move
	 *     SimpleSpell returns Move
	 *     Move returns Move
	 *
	 * Constraint:
	 *     movement=Movement
	 * </pre>
	 */
	protected void sequence_Move(ISerializationContext context, Move semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellLangPackage.Literals.MOVE__MOVEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellLangPackage.Literals.MOVE__MOVEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveAccess().getMovementMovementEnumRuleCall_1_0(), semanticObject.getMovement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpellExpression returns Say
	 *     SpellExpression.ComplexSpell_1_0 returns Say
	 *     SimpleSpell returns Say
	 *     Say returns Say
	 *
	 * Constraint:
	 *     word=ID
	 * </pre>
	 */
	protected void sequence_Say(ISerializationContext context, Say semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellLangPackage.Literals.SAY__WORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellLangPackage.Literals.SAY__WORD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSayAccess().getWordIDTerminalRuleCall_1_0(), semanticObject.getWord());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpellDefinition returns SpellDefinition
	 *
	 * Constraint:
	 *     (name=ID spellCode=SpellExpression)
	 * </pre>
	 */
	protected void sequence_SpellDefinition(ISerializationContext context, SpellDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellLangPackage.Literals.SPELL_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellLangPackage.Literals.SPELL_DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, SpellLangPackage.Literals.SPELL_DEFINITION__SPELL_CODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellLangPackage.Literals.SPELL_DEFINITION__SPELL_CODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpellDefinitionAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSpellDefinitionAccess().getSpellCodeSpellExpressionParserRuleCall_1_0(), semanticObject.getSpellCode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpellExpression returns ComplexSpell
	 *     SpellExpression.ComplexSpell_1_0 returns ComplexSpell
	 *
	 * Constraint:
	 *     (start=SpellExpression_ComplexSpell_1_0 next+=SimpleSpell)
	 * </pre>
	 */
	protected void sequence_SpellExpression(ISerializationContext context, ComplexSpell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SpellInvocation returns SpellInvocation
	 *
	 * Constraint:
	 *     spell=[SpellDefinition|ID]
	 * </pre>
	 */
	protected void sequence_SpellInvocation(ISerializationContext context, SpellInvocation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpellLangPackage.Literals.SPELL_INVOCATION__SPELL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpellLangPackage.Literals.SPELL_INVOCATION__SPELL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpellInvocationAccess().getSpellSpellDefinitionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SpellLangPackage.Literals.SPELL_INVOCATION__SPELL, false));
		feeder.finish();
	}
	
	
}
