/**
 * generated by Xtext 2.33.0
 */
package uk.ac.kcl.inf.mdd.generator;

import java.util.Arrays;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import uk.ac.kcl.inf.mdd.spellLang.ComplexSpell;
import uk.ac.kcl.inf.mdd.spellLang.Model;
import uk.ac.kcl.inf.mdd.spellLang.Move;
import uk.ac.kcl.inf.mdd.spellLang.Movement;
import uk.ac.kcl.inf.mdd.spellLang.Say;
import uk.ac.kcl.inf.mdd.spellLang.SimpleSpell;
import uk.ac.kcl.inf.mdd.spellLang.SpellExpression;
import uk.ac.kcl.inf.mdd.spellLang.SpellInvocation;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class SpellLangGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    StringConcatenation _builder = new StringConcatenation();
    String _className = this.className(resource);
    _builder.append(_className);
    _builder.append(".java");
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    fsa.generateFile(_builder.toString(), 
      this.doGenerate(((Model) _head), this.className(resource)));
  }

  public String className(final Resource resource) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Spells");
    String _firstUpper = StringExtensions.toFirstUpper(resource.getURI().trimFileExtension().lastSegment());
    _builder.append(_firstUpper);
    return _builder.toString();
  }

  public CharSequence doGenerate(final Model spells, final String className) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("public class ");
    _builder.append(className);
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("public static void main (String[] args) {");
    _builder.newLine();
    _builder.append("\t\t");
    final Function1<SpellInvocation, CharSequence> _function = (SpellInvocation si) -> {
      return this.doGenerate(si);
    };
    String _join = IterableExtensions.join(ListExtensions.<SpellInvocation, CharSequence>map(spells.getSession(), _function), "\n");
    _builder.append(_join, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  public CharSequence doGenerate(final SpellInvocation si) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("System.out.println(\"");
    String _generateSpellCode = this.generateSpellCode(si.getSpell().getSpellCode());
    _builder.append(_generateSpellCode);
    _builder.append("\");");
    _builder.newLineIfNotEmpty();
    return _builder;
  }

  protected String _generateSpellCode(final SpellExpression se) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder.toString();
  }

  protected String _generateSpellCode(final SimpleSpell ss) {
    StringConcatenation _builder = new StringConcatenation();
    return _builder.toString();
  }

  protected String _generateSpellCode(final Say s) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Say ");
    String _word = s.getWord();
    _builder.append(_word);
    return _builder.toString();
  }

  protected String _generateSpellCode(final Move m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Move ");
    Movement _movement = m.getMovement();
    _builder.append(_movement);
    return _builder.toString();
  }

  protected String _generateSpellCode(final ComplexSpell cs) {
    StringConcatenation _builder = new StringConcatenation();
    String _generateSpellCode = this.generateSpellCode(cs.getStart());
    _builder.append(_generateSpellCode);
    _builder.append("; ");
    final Function1<SimpleSpell, String> _function = (SimpleSpell se) -> {
      return this.generateSpellCode(se);
    };
    String _join = IterableExtensions.join(ListExtensions.<SimpleSpell, String>map(cs.getNext(), _function), "; ");
    _builder.append(_join);
    return _builder.toString();
  }

  public String generateSpellCode(final SpellExpression m) {
    if (m instanceof Move) {
      return _generateSpellCode((Move)m);
    } else if (m instanceof Say) {
      return _generateSpellCode((Say)m);
    } else if (m instanceof ComplexSpell) {
      return _generateSpellCode((ComplexSpell)m);
    } else if (m instanceof SimpleSpell) {
      return _generateSpellCode((SimpleSpell)m);
    } else if (m != null) {
      return _generateSpellCode(m);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(m).toString());
    }
  }
}
